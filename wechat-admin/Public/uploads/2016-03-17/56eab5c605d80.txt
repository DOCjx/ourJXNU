自我介绍：

	XX,你好！我是江西师范大学本科生，今年20岁，我叫谢志强。
	首先很高兴能够接到您的电话面试，并有机会向您请教和学习,我感到非常的荣幸。

	我在大学期间，自主管理时间，自主学习。采用“自顶向下”的学习思路，所以我的学习能力、解决问题能力比较强。
							（自顶向下就是 把高级的问题分解成低级的问题，然后把低级的问题逐个击破）
	还加入江西师大优秀Web开发团队（宏奕工作室），一起承接商业项目，
	并且多次担任项目组中的主力开发，我有近两年的项目开发经验。
	同时我也有自己的github仓库，博客园账号，在这些平台和其他程序员的技术交流也让我迅速的成长。
	关注新技术，喜欢挑战新事物；很享受在学习新技术时的思维的碰撞  和  技术之间相通的一些思路。
	同时对
	热爱生活，热爱学习，热爱编程，抗压能力较强。				
	-------------------------------------------------------------------------------------------------------------------------------------------
	XX,你好！我是江西师范大学本科生，我叫谢志强。
	首先很高兴能够接到您的电话面试，并有机会向您请教和学习,我感到非常的荣幸。

	虽然我们学校只是个普通的二本学校，但是我们学校有一支优秀的Web开发团队叫宏奕工作室，
	我们一起学习技术，一起举办web开发培训，一起承接商业项目，我在做项目时也多次担任项目组中的主力开发，所以我是有一定的项目开发经验的。
	另外我在大学期间，能够自主的管理时间，自主学习。采用“自顶向下”的学习思路，去解决我所遇到的问题，所以我的学习能力、解决问题能力比较强。
							（自顶向下就是 把高级的问题分解成低级的问题，然后把低级的问题逐个击破）
	同时我也有自己的github仓库，博客园账号，在这些平台和其他程序员的技术交流也让我开阔了视野，迅速的成长。
	我也经常关注新技术，喜欢挑战新事物；很享受在学习新技术时和自己之前学习的技术的思维的碰撞  和  技术之间相通的一些思路。	
	我也爱好编程，我的性格也适合编程，我希望能达到一种兴趣，工作，生活三位一体的一种状态。
	我的缺点可能就是大学期间大部分时间都用来做项目了，所以一些基础的算法知识只是了解一些，不是很深。

	-------------------------------------------------------------------------------------------------------------------------------------------------------
框架是很多，所以说前端的水很深.. 
一个新技术的出现通常是为了解决特定的问题。
根据需要来选择就可以了。
理解他的原理和思想，了解使用方法就可以了。
-----------------------------------------------

理解React
React 是一个 Facebook 和 Instagram 用来创建用户界面的 JavaScript 库。

很多人认为 React 是 MVC 中的 V（视图）。

我们创造 React 是为了解决一个问题：构建随着时间数据不断变化的大规模应用程序。为了达到这个目标，React 采用下面两个主要的思想。

----2.1---Just the ui  只是view层  ------------------------------------------
React 负责UI层面的展现，尽管很多人用React作[MVC]架构中的View层,但这并不是React的本意。

一般的情况下，我们在开发过程中，通常会使用模板或者直接使用HTML来构建UI，
而HTML是静态的，使用模板在大多数情况下是可以满足需求的，
但是在复杂的逻辑情境中就显得有些吃力了，过多的if else或者逻辑控制在模板里，
都会让代码变得难以维护，当然这还是说整个项目中使用统一的模板的情况下。

React换了一种思路解决问题，它把UI拆分成组件，
而不是通过模板引擎和展示逻辑，
使得它可以易于拓展和维护。
因此它引入了JSX这种语法规则，可以让我们使用类似HTML的语法去写js的函数调用。

--------2.2 virtual dom  虚拟dom  -------------

浏览器渲染页面的一般过程通常是这样的：

1 加载html->生成DOM树->解析css生成Render树->生成页面
 
<script       src="script.js"></script>
	没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。
<script async src="script.js"></script>
	有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。
<script defer src="myscript.js"></script>
	有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

那么React的virtual dom是怎么做的呢？

1 生成virtual dom -> diff -> 必要的DOM更新
在这里面大部分的操作放在js中去完成，因为我们都知道dom操作是很昂贵的。所以在一般的情况下React的性能还是很不错的。


-----2.3 data flow 数据单向流动 -------------------

React中的数据流是沿着组件树从上到下单向流动的。

这里的data flow指的是一种应用架构的实现方式，
比如说，数据存放在哪里，在哪里触发事件，如何响应用户操作。
它不是React提供的什么新功能，应该是React构建应用的实践。
我们理解了之后的Flux或许就更加容易理解data flow这个概念了。
--------------------------------------------------------------------

模板出现的初衷是让非开发人员也能对界面做一定的修改。
但这个初衷在当前Web程序里已完全不适用，每个模板背后的代码逻辑严重依赖模板中的内容和DOM结构，两者是紧密耦合的。
即使做到文件位置的分离，实际上两者还是一体的，并且为了两者之间的协作而不得不引入很多机制和概念。

------------
所谓组件，就是状态机器
React将用户界面看做简单的状态机器。当组件处于某个状态时，那么就输出这个状态对应的界面。通过这种方式，就很容易去保证界面的一致性。
在React中，你简单的去更新某个组件的状态，然后输出基于新状态的整个界面。React负责以最高效的方式去比较两个界面并更新DOM树。

--------------
只读数据并不是Facebook的全新发明，而是起源于Clojure, Scala, Haskell等函数式编程语言。
只读的数据可以让代码更加的安全和易于维护，你不再需要担心数据在某个角落被某段神奇的代码所修改；
也就不必再为了找到修改的地方而苦苦调试。
而结合React，只读数据能够让React的组件仅仅通过比较对象引用是否相等来决定自身是否要重新Render。
这在复杂的界面上可以极大的提高性能。

--------------
CommonJS和AMD是用于JavaScript模块管理的两大规范，前者定义的是模块的同步加载，主要用于NodeJS；
而后者则是异步加载，通过requirejs等工具适用于前端。
随着npm成为主流的JavaScript组件发布平台，越来越多的前端项目也依赖于npm上的项目，或者自身就会发布到npm平台。
因此，让前端项目更方便的使用npm上的资源成为一大需求。
于是诞生了类似browserify这样的工具，
代码中可以使用require函数直接以同步语法形式引入npm模块，
打包后再由浏览器执行。
-----------------------
webpack优点

同时支持CommonJS和AMD模块（对于新项目，推荐直接使用CommonJS）； 
串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持； 
可以基于配置或者智能分析打包成多个文件，实现公共模块或者按需加载； 
支持对CSS，图片等资源进行打包，从而无需借助Grunt或Gulp； 
开发时在内存中完成打包，性能更快，完全可以支持开发过程的实时打包需求； 
对sourcemap有很好的支持，易于调试。
---------
<button onClick={this.checkAndSubmit.bind(this)}>Submit</button>
和原生HTML定义事件的唯一区别就是JSX采用驼峰写法来描述事件名称，
大括号中仍然是标准的JavaScript表达式，返回一个事件处理函数。
在JSX中你不需要关心什么时机去移除事件绑定，
因为React会在对应的真实DOM节点移除时就自动解除了事件绑定。
React并不会真正的绑定事件到每一个具体的元素上，
而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，
然后通过事件的target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，
React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。
===================================
闭包有三个特性：

1.函数嵌套函数
2.函数内部可以引用外部的参数和变量
3.参数和变量不会被垃圾回收机制回收



闭包，就是用来实现这种嵌套时还能够层层向上访问变量的功能的！
对的，它就是一个简单的编译器技巧，用来使得内部函数能够访问上级函数的变量。

简单来说，它具体实现的方法为，在每个函数上附加上一个额外的隐藏对象，这个对象其实就叫做闭包对象，
记录了本函数内部的变量列表而已。
而且这个闭包对象还保存了一个指向上级函数的闭包对象的引用。

这样一来，就形成了一个链条。
当我们在一个函数里访问一个变量的时候，编译器会先看看在本闭包里到底有没有这个变量，
如果没有就向上寻找。如果找到，那就用，如果一直找到头也没有，那就提示出错。

=========================================

javascript的垃圾回收原理

（1）、在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收；
（2）、如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。

===================


=======================
一个页面从输入 URL 到页面加载完的过程中都发生了什么事情？

1.浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤如果资源未缓存，发起新请求

  - 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。

  - 检验新鲜通常有两个HTTP头进行控制Expires( HTTP1.0  绝对时间表示缓存新鲜日期 )
    和Cache-Control(HTTP1.1 max-age=,值为以秒为单位的最大新鲜时间 )

2.浏览器解析 url 获取协议，主机，端口，path

3.浏览器组装一个HTTP（GET）请求报文

4.浏览器获取主机ip地址

  -浏览器缓存
  -本机缓存
  -hosts文件
  -路由器缓存
  -ISP DNS缓存
  -DNS递归查询（可能存在负载均衡导致每次IP不一样）

5.打开一个socket（套接字）与目标IP地址，端口建立TCP链接，三次握手

  -客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口
  -服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
  -客户端发送ACK=Y+1， Seq=Z

6.TCP链接建立后发送HTTP请求

7.服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序

8.服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码

9.处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作

10.服务器将响应报文通过TCP连接发送回浏览器

11.浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次挥手

  -主动方发送 Fin=1， Ack=Z， Seq= X 报文
  -被动方发送 ACK=X+1， Seq=Z 报文
  -被动方发送 Fin=1， ACK=X， Seq=Y 报文
  -主动方发送 ACK=Y， Seq=X 报文

12.浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同

13.如果资源可缓存，进行缓存

14.对响应进行解码（例如gzip压缩）

15.根据资源类型决定如何处理（假设资源为HTML文档）

16.解析HTML文档 --> 构件DOM树 --> 下载资源 --> 构造CSSOM树 --> 执行js脚本

17.构建DOM树：
  -Tokenizing：根据HTML规范将字符流解析为标记
  -Lexing：词法分析将标记转换为对象并定义属性和规则
  -DOM construction：根据HTML标记关系将对象组成DOM树

18.解析过程中遇到图片、样式表、js文件，启动下载

19.构建CSSOM树：
  -Tokenizing：字符流转换为标记流
  -Node：根据标记创建节点
  -CSSOM：节点创建CSSOM树

20.根据DOM树和CSSOM树构建渲染树
  -从DOM树的根节点遍历所有可见节点，
	不可见节点包括：
		1）script,meta这样本身不可见的标签。
		2) 被css隐藏的节点，如display: none
  -对每一个可见节点，找到恰当的CSSOM规则并应用
  -发布可视节点的内容和计算样式

21.js解析如下
  -
  -

22.显示页面（HTML解析过程中会逐步显示页面）



=======================================================
margin 负值

负的margin值不会影响box实际大小，如果是负的top或者left值会引起box的向上或者向左位置的移动，如果是bottom或者right只会影响下面box的显示的参考线。










